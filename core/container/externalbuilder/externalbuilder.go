/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package externalbuilder

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"time"

	"github.com/hyperledger/fabric/common/flogging"
	"github.com/hyperledger/fabric/core/container/ccintf"
	"github.com/hyperledger/fabric/core/peer"
	"github.com/pkg/errors"
)

var (
	// DefaultPropagateEnvironment enumerates the list of environment variables that are
	// implicitly propagated to external builder and launcher commands.
	DefaultPropagateEnvironment = []string{"LD_LIBRARY_PATH", "LIBPATH", "PATH", "TMPDIR"}

	logger = flogging.MustGetLogger("chaincode.externalbuilder")
)

// BuildInfo contains metadata is that is saved to the local file system with the
// assets generated by an external builder. This is used to associate build output
// with the builder that generated it.
type BuildInfo struct {
	// BuilderName is the user provided name of the external builder.
	BuilderName string `json:"builder_name"`
}

// Detector 负责协调外部构建器的检测和构建过程。
type Detector struct {
	DurablePath string     // DurablePath 是链码资产持久化的文件系统位置。
	Builders    []*Builder // Builders 是检测和构建过程将使用的构建器。
}

// CachedBuild 返回已经构建的构建实例，如果没有找到实例则返回nil。
// 仅当遇到意外情况时才返回错误。
// 方法接收者：d（Detector类型的指针）
// 输入参数：
//   - ccid：string类型，表示链码ID。
//
// 返回值：
//   - *Instance：表示已构建的实例。
//   - error：如果遇到意外情况，则返回错误。
func (d *Detector) CachedBuild(ccid string) (*Instance, error) {
	// 用于确保从文件名中删除特殊字符
	durablePath := filepath.Join(d.DurablePath, SanitizeCCIDPath(ccid))
	_, err := os.Stat(durablePath)
	if os.IsNotExist(err) {
		return nil, nil
	}

	if err != nil {
		return nil, errors.WithMessage(err, "检测到现有构建，但检查它时出错")
	}

	buildInfoPath := filepath.Join(durablePath, "build-info.json")
	buildInfoData, err := ioutil.ReadFile(buildInfoPath)
	if err != nil {
		return nil, errors.WithMessagef(err, "无法读取 %s 以获取链码构建信息", buildInfoPath)
	}

	var buildInfo BuildInfo
	if err := json.Unmarshal(buildInfoData, &buildInfo); err != nil {
		return nil, errors.WithMessagef(err, "格式不正常的链码生成信息, 位于 '%s'", buildInfoPath)
	}

	for _, builder := range d.Builders {
		if builder.Name == buildInfo.BuilderName {
			return &Instance{
				PackageID:   ccid,
				Builder:     builder,
				BldDir:      filepath.Join(durablePath, "bld"),
				ReleaseDir:  filepath.Join(durablePath, "release"),
				TermTimeout: 5 * time.Second,
			}, nil
		}
	}

	return nil, errors.Errorf("链码 '%s' 已使用生成器 '%s' 生成, 但该生成器不再可用", ccid, buildInfo.BuilderName)
}

// Build 执行外部构建器的检测和构建过程。
//
// 在运行检测和构建过程之前，检测器首先检查持久化路径中是否存在先前构建的结果。
// 如果找到，则跳过检测和构建过程，并返回现有的实例。
// 方法接收者：d（Detector类型的指针）
// 输入参数：
//   - ccid：string类型，表示链码ID。
//   - mdBytes：[]byte类型，表示链码元数据的字节数据。
//   - codeStream：io.Reader类型，表示链码代码的读取器。
//
// 返回值：
//   - *Instance：表示构建的实例。
//   - error：如果构建过程中出错，则返回错误。
func (d *Detector) Build(ccid string, mdBytes []byte, codeStream io.Reader) (*Instance, error) {
	// 一个小的优化: 防止将构建包分解到
	// 文件系统，除非定义了外部构建器。
	if len(d.Builders) == 0 {
		return nil, nil
	}

	// 查找缓存实例。返回已经构建的构建实例，如果没有找到实例则返回nil
	i, err := d.CachedBuild(ccid)
	if err != nil {
		return nil, errors.WithMessage(err, "无法还原现有的链码实例")
	}

	if i != nil {
		return i, nil
	}

	// 创建运行外部构建过程所需的目录，并提取链码包资源
	buildContext, err := NewBuildContext(ccid, mdBytes, codeStream)
	if err != nil {
		return nil, errors.WithMessage(err, "创建运行外部构建过程所需的目录，并提取链码包资源出错")
	}
	defer buildContext.Cleanup()

	// 方法用于在给定的构建上下文中检测可用的构建器，并返回第一个匹配的构建器
	builder := d.detect(buildContext)
	if builder == nil {
		logger.Debugf("未检测到 %s 的外部生成器", ccid)
		return nil, nil
	}

	if err := builder.Build(buildContext); err != nil {
		return nil, errors.WithMessage(err, "外部生成器无法生成")
	}

	if err := builder.Release(buildContext); err != nil {
		return nil, errors.WithMessage(err, "外部生成器无法释放")
	}

	durablePath := filepath.Join(d.DurablePath, SanitizeCCIDPath(ccid))

	err = os.Mkdir(durablePath, 0o700)
	if err != nil {
		return nil, errors.WithMessagef(err, "无法创建dir '%s' 以保留生成输出", durablePath)
	}

	buildInfo, err := json.Marshal(&BuildInfo{
		BuilderName: builder.Name,
	})
	if err != nil {
		os.RemoveAll(durablePath)
		return nil, errors.WithMessage(err, "无法序列化 build-info.json")
	}

	err = ioutil.WriteFile(filepath.Join(durablePath, "build-info.json"), buildInfo, 0o600)
	if err != nil {
		os.RemoveAll(durablePath)
		return nil, errors.WithMessage(err, "无法写入 build-info.json")
	}

	durableReleaseDir := filepath.Join(durablePath, "release")
	err = CopyDir(logger, buildContext.ReleaseDir, durableReleaseDir)
	if err != nil {
		return nil, errors.WithMessagef(err, "无法将生成上下文 '%s' 发布移动或复制到账本的持久位置 '%s'", durableReleaseDir, durablePath)
	}

	durableBldDir := filepath.Join(durablePath, "bld")
	err = CopyDir(logger, buildContext.BldDir, durableBldDir)
	if err != nil {
		return nil, errors.WithMessagef(err, "无法移动或复制构建上下文 '%s' 到账本持久位置 '%s'", durableBldDir, durablePath)
	}

	return &Instance{
		PackageID:   ccid,
		Builder:     builder,
		BldDir:      durableBldDir,
		ReleaseDir:  durableReleaseDir,
		TermTimeout: 5 * time.Second,
	}, nil
}

// detect 方法用于在给定的构建上下文中检测可用的构建器，并返回第一个匹配的构建器。
// 方法接收者：d（Detector类型的指针）
// 输入参数：
//   - buildContext：*BuildContext类型，表示构建上下文。
//
// 返回值：
//   - *Builder：表示检测到的构建器。
func (d *Detector) detect(buildContext *BuildContext) *Builder {
	// 遍历所有的构建器
	for _, builder := range d.Builders {
		// 调用构建器的 Detect 方法检测构建上下文
		if builder.Detect(buildContext) {
			// 如果检测到匹配的构建器，则返回该构建器
			return builder
		}
	}
	// 如果没有检测到匹配的构建器，则返回nil
	return nil
}

// BuildContext holds references to the various assets locations necessary to
// execute the detect, build, release, and run programs for external builders
type BuildContext struct {
	CCID        string
	ScratchDir  string
	SourceDir   string
	ReleaseDir  string
	MetadataDir string
	BldDir      string
}

// NewBuildContext 创建运行外部构建过程所需的目录，并提取链码包资源。
//
// BuildContext的使用者在构建过程完成后必须调用Cleanup函数来删除临时文件系统资源。
// 方法接收者：无（该函数是一个独立的函数）
// 输入参数：
//   - ccid：string类型，表示链码ID。
//   - mdBytes：[]byte类型，表示链码元数据的字节数据。
//   - codePackage：io.Reader类型，表示链码代码包的读取器。
//
// 返回值：
//   - *BuildContext：表示构建上下文。
//   - error：如果创建过程中出错，则返回错误。
func NewBuildContext(ccid string, mdBytes []byte, codePackage io.Reader) (bc *BuildContext, err error) {
	// 创建临时目录
	scratchDir, err := ioutil.TempDir("", "fabric-"+SanitizeCCIDPath(ccid))
	if err != nil {
		return nil, errors.WithMessage(err, "无法创建外部构建链码临时目录")
	}

	// 在函数返回前删除临时目录
	defer func() {
		if err != nil {
			os.RemoveAll(scratchDir)
		}
	}()

	// 创建源代码目录
	sourceDir := filepath.Join(scratchDir, "src")
	if err = os.Mkdir(sourceDir, 0o700); err != nil {
		return nil, errors.WithMessage(err, "无法创建外部构建过程所需的 src 源目录")
	}

	// 创建元数据目录
	metadataDir := filepath.Join(scratchDir, "metadata")
	if err = os.Mkdir(metadataDir, 0o700); err != nil {
		return nil, errors.WithMessage(err, "无法创建外部构建过程所需的 metadata 元数据目录")
	}

	// 创建构建目录
	outputDir := filepath.Join(scratchDir, "bld")
	if err = os.Mkdir(outputDir, 0o700); err != nil {
		return nil, errors.WithMessage(err, "无法创建外部构建过程所需的 bld 构建目录")
	}

	// 创建发布目录
	releaseDir := filepath.Join(scratchDir, "release")
	if err = os.Mkdir(releaseDir, 0o700); err != nil {
		return nil, errors.WithMessage(err, "无法创建外部构建过程所需的 release 发布目录")
	}

	// 解压缩链码代码包到源代码目录
	err = Untar(codePackage, sourceDir)
	if err != nil {
		return nil, errors.WithMessage(err, "无法解压缩链码包到源代码目录")
	}

	// 将链码元数据写入元数据目录
	err = ioutil.WriteFile(filepath.Join(metadataDir, "metadata.json"), mdBytes, 0o700)
	if err != nil {
		return nil, errors.WithMessage(err, "将链码元数据写入元数据目录出错")
	}

	// 创建并返回构建上下文
	return &BuildContext{
		ScratchDir:  scratchDir,
		SourceDir:   sourceDir,
		MetadataDir: metadataDir,
		BldDir:      outputDir,
		ReleaseDir:  releaseDir,
		CCID:        ccid,
	}, nil
}

// Cleanup removes the build context artifacts.
func (bc *BuildContext) Cleanup() {
	os.RemoveAll(bc.ScratchDir)
}

var pkgIDreg = regexp.MustCompile("[<>:\"/\\\\|\\?\\*&]")

// SanitizeCCIDPath 用于确保从文件名中删除特殊字符。
// 方法接收者：无（该函数是一个独立的函数）
// 输入参数：
//   - ccid：string类型，表示链码ID。
//
// 返回值：
//   - string：表示经过处理后的链码ID路径。
func SanitizeCCIDPath(ccid string) string {
	// 使用正则表达式将特殊字符替换为"-"
	sanitized := pkgIDreg.ReplaceAllString(ccid, "-")
	return sanitized
}

// A Builder is used to interact with an external chaincode builder and launcher.
type Builder struct {
	PropagateEnvironment []string
	Location             string
	Logger               *flogging.FabricLogger
	Name                 string
	MSPID                string
}

// CreateBuilders will construct builders from the peer configuration.
func CreateBuilders(builderConfs []peer.ExternalBuilder, mspid string) []*Builder {
	var builders []*Builder
	for _, builderConf := range builderConfs {
		builders = append(builders, &Builder{
			Location:             builderConf.Path,
			Name:                 builderConf.Name,
			PropagateEnvironment: builderConf.PropagateEnvironment,
			Logger:               logger.Named(builderConf.Name),
			MSPID:                mspid,
		})
	}
	return builders
}

// Detect 方法用于运行 `detect` 脚本。
// 方法接收者：b（Builder类型的指针）
// 输入参数：
//   - buildContext：*BuildContext类型，表示构建上下文。
//
// 返回值：
//   - bool：表示是否成功运行 `detect` 脚本。
func (b *Builder) Detect(buildContext *BuildContext) bool {
	// 构建 `detect` 脚本的路径
	detectCmd := ""
	switch runtime.GOOS {
	case "linux":
		detectCmd = filepath.Join(b.Location, "bin", "detect")
	case "windows":
		detectCmd = filepath.Join(b.Location, "bin", "detect.exe")
	default:
		detectCmd = filepath.Join(b.Location, "bin", "detect")
	}

	_, err := os.Stat(detectCmd)
	if err != nil {
		if os.IsNotExist(err) {
			// 使用本地代码
			err := RunDetect("", "", buildContext.MetadataDir)
			if err != nil {
				logger.Debugf("生成器 '%s' 检测失败: %s", b.Name, err)
				return false
			}
			return true
		}
	}

	// 使用外部脚本, 创建命令对象
	cmd := b.NewCommand(detectCmd, buildContext.SourceDir, buildContext.MetadataDir)

	// 运行命令
	err = b.runCommand(cmd)
	if err != nil {
		logger.Debugf("生成器 '%s' 检测失败: %s", b.Name, err)
		return false
	}

	return true
}

// Build 运行 “构建” 脚本。
func (b *Builder) Build(buildContext *BuildContext) error {
	buildCmd := ""
	switch runtime.GOOS {
	case "linux":
		buildCmd = filepath.Join(b.Location, "bin", "build")
	case "windows":
		buildCmd = filepath.Join(b.Location, "bin", "build.exe")
	default:
		buildCmd = filepath.Join(b.Location, "bin", "build")
	}

	_, err := os.Stat(buildCmd)
	if err != nil {
		if os.IsNotExist(err) {
			// 使用本地代码
			err := RunBuild("", buildContext.SourceDir, buildContext.MetadataDir, buildContext.BldDir)
			if err != nil {
				logger.Debugf("外部生成器 '%s' 失败: %s", b.Name, err)
				return errors.Wrapf(err, "外部生成器 '%s' 失败", b.Name)
			}
			return nil
		}
	}

	// 外部使用脚本
	cmd := b.NewCommand(buildCmd, buildContext.SourceDir, buildContext.MetadataDir, buildContext.BldDir)

	err = b.runCommand(cmd)
	if err != nil {
		return errors.Wrapf(err, "外部生成器 '%s' 失败", b.Name)
	}

	return nil
}

// Release 运行 “release” 脚本。
func (b *Builder) Release(buildContext *BuildContext) error {
	releaseCmd := ""
	switch runtime.GOOS {
	case "linux":
		releaseCmd = filepath.Join(b.Location, "bin", "release")
	case "windows":
		releaseCmd = filepath.Join(b.Location, "bin", "release.exe")
	default:
		releaseCmd = filepath.Join(b.Location, "bin", "release")
	}

	_, err := os.Stat(releaseCmd)
	if err != nil {
		if os.IsNotExist(err) {
			// 使用本地代码
			err := RunRelease("", buildContext.BldDir, buildContext.ReleaseDir)
			if err != nil {
				logger.Debugf("外部生成器 '%s' 失败: %s", b.Name, err)
				return errors.Wrapf(err, "外部生成器 '%s' 失败", b.Name)
			}
			return nil
		}
	}

	// 使用外部脚本
	_, err = exec.LookPath(releaseCmd)
	if err != nil {
		b.Logger.Debugf("正在跳过 '%s' 的发布步骤,因为找不到发布二进制文件", buildContext.CCID)
		return nil
	}

	cmd := b.NewCommand(releaseCmd, buildContext.BldDir, buildContext.ReleaseDir)
	err = b.runCommand(cmd)
	if err != nil {
		return errors.Wrapf(err, "生成器 '%s' 发布失败", b.Name)
	}

	return nil
}

// runConfig is serialized to disk when launching.
type runConfig struct {
	CCID        string `json:"chaincode_id"`
	PeerAddress string `json:"peer_address"`
	ClientCert  string `json:"client_cert"` // PEM encoded client certificate
	ClientKey   string `json:"client_key"`  // PEM encoded client key
	RootCert    string `json:"root_cert"`   // PEM encoded peer chaincode certificate
	MSPID       string `json:"mspid"`
}

func newRunConfig(ccid string, peerConnection *ccintf.PeerConnection, mspid string) runConfig {
	var tlsConfig ccintf.TLSConfig
	if peerConnection.TLSConfig != nil {
		tlsConfig = *peerConnection.TLSConfig
	}

	return runConfig{
		PeerAddress: peerConnection.Address,
		CCID:        ccid,
		ClientCert:  string(tlsConfig.ClientCert),
		ClientKey:   string(tlsConfig.ClientKey),
		RootCert:    string(tlsConfig.RootCert),
		MSPID:       mspid,
	}
}

// Run 启动' run '脚本并返回一个会话，该会话可用于发送信号并等待终止。
func (b *Builder) Run(ccid, bldDir string, peerConnection *ccintf.PeerConnection) (*Session, error) {
	launchDir, err := ioutil.TempDir("", "fabric-run")
	if err != nil {
		return nil, errors.WithMessage(err, "could not create temp run dir")
	}

	rc := newRunConfig(ccid, peerConnection, b.MSPID)
	marshaledRC, err := json.Marshal(rc)
	if err != nil {
		return nil, errors.WithMessage(err, "could not marshal run config")
	}

	if err := ioutil.WriteFile(filepath.Join(launchDir, "chaincode.json"), marshaledRC, 0o600); err != nil {
		return nil, errors.WithMessage(err, "could not write root cert")
	}

	run := ""
	switch runtime.GOOS {
	case "linux":
		run = filepath.Join(b.Location, "bin", "run")
	case "windows":
		run = filepath.Join(b.Location, "bin", "run.exe")
	default:
		run = filepath.Join(b.Location, "bin", "run")
	}

	cmd := b.NewCommand(run, bldDir, launchDir)
	sess, err := Start(b.Logger, cmd, func(error) { os.RemoveAll(launchDir) })
	if err != nil {
		os.RemoveAll(launchDir)
		return nil, errors.Wrapf(err, "builder '%s' run failed to start", b.Name)
	}

	return sess, nil
}

// runCommand 运行命令并等待其完成。
func (b *Builder) runCommand(cmd *exec.Cmd) error {
	// 方法用于启动提供的命令，并返回一个 Session 对象，该对象可用于等待命令完成或向进程发送信号
	sess, err := Start(b.Logger, cmd)
	if err != nil {
		return err
	}
	return sess.Wait()
}

// NewCommand 方法用于创建一个已配置的 exec.Cmd，以将调用环境修剪为外部构建器的 PropagateEnvironment 和 DefaultPropagateEnvironment 中指定的环境变量。
// 方法接收者：b（Builder类型的指针）
// 输入参数：
//   - name：string类型，表示要执行的命令的名称。
//   - args：...string类型，表示要传递给命令的参数。
//
// 返回值：
//   - *exec.Cmd：表示已配置的 exec.Cmd 对象。
func (b *Builder) NewCommand(name string, args ...string) *exec.Cmd {
	// 创建一个 exec.Cmd 对象，表示要执行的命令
	cmd := exec.Command(name, args...)

	// 获取要传递给命令的环境变量列表
	propagationList := appendDefaultPropagateEnvironment(b.PropagateEnvironment)

	// 遍历环境变量列表
	for _, key := range propagationList {
		// 检查环境变量是否存在
		if val, ok := os.LookupEnv(key); ok {
			// 将环境变量添加到命令的环境变量列表中
			cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, val))
		}
	}

	return cmd
}

func appendDefaultPropagateEnvironment(propagateEnvironment []string) []string {
	for _, variable := range DefaultPropagateEnvironment {
		if !contains(propagateEnvironment, variable) {
			propagateEnvironment = append(propagateEnvironment, variable)
		}
	}
	return propagateEnvironment
}

func contains(propagateEnvironment []string, key string) bool {
	for _, variable := range propagateEnvironment {
		if key == variable {
			return true
		}
	}
	return false
}
